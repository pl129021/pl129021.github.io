<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/05/11/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>2021/05/11/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="CopyOnWriteArraySet源码阅读"><a href="#CopyOnWriteArraySet源码阅读" class="headerlink" title="CopyOnWriteArraySet源码阅读"></a>CopyOnWriteArraySet源码阅读</h1><blockquote><pre><code class="java">Set sets = new CopyOnWriteArraySet(); // JUC包下的并发安全 CopyOnWriteArraySet</code></pre></blockquote><blockquote><p>通过查看源码可知———–&gt;CopyOnWriteArraySet的底层就是new了一个==CopyOnWriteArrayList==</p></blockquote><pre><code class="java">/** * 当我们实例化CopyOnWriteArraySet集合时，java底层创建的是CopyOnWriteArrayList集合 */public CopyOnWriteArraySet() &#123;    al = new CopyOnWriteArrayList&lt;E&gt;();&#125;</code></pre><blockquote><p>new CopyOnWriteArrayList<E>();</p></blockquote><pre><code class="java">/** * 当我们实例化CopyOnWriteArrayList集合时,底层调用了setArray((new Object[0]))方法 */public CopyOnWriteArrayList() &#123;    setArray(new Object[0]);&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123;    array = a;&#125;/*** transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。* volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。*/private transient volatile Object[] array;</code></pre><blockquote><p>add()方法</p></blockquote><pre><code class="java">/** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123;    //添加元素到集合中前先加上lock锁所以==CopyOnWriteArrayList==是线程安全的    final ReentrantLock lock = this.lock;    lock.lock();    //下面就执行添加元素的操作    try &#123;        //获取当前数组        Object[] elements = getArray();        //获取当前数组的长度        int len = elements.length;        //复制当前数组为一个长度+1的新数组        Object[] newElements = Arrays.copyOf(elements, len + 1);        //把元素添加到新的数组中        newElements[len] = e;        //再用新的数组替换当前的数组 就完成了添加元素的操作        setArray(newElements);        return true;    &#125; finally &#123;        //最后释放lock锁        lock.unlock();    &#125;&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123;    array = a;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-3-16-%E5%88%86%E5%B8%83%E5%BC%8F-dubbo-zookeeper/"/>
      <url>2021/05/11/2021-3-16-%E5%88%86%E5%B8%83%E5%BC%8F-dubbo-zookeeper/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式-Dubbo-Zookeeper"><a href="#分布式-Dubbo-Zookeeper" class="headerlink" title="分布式/Dubbo/Zookeeper"></a>分布式/Dubbo/Zookeeper</h1><blockquote><p>什么是分布式系统?</p></blockquote><p>==分布式系统是若干独立计算机的集合，这计算机对用户来说就像单个相关系统。==</p><blockquote><p>什么是Dubbo?</p></blockquote><p>一个远程调用服务的分布式框架，可以实现远程通讯、动态配置、地址路由。Dubbo实现服务调用是通过RPC的方式</p><blockquote><p>什么是Zookeeper?</p></blockquote><p><em>ZooKeeper</em>是一个分布式的，开放源码的分布式应用程序协调服务，类似一个服务注册中心。</p><blockquote><p>Springboot实现简单分布式demo</p></blockquote><p>首先需要安装zookeeper并且启动zookeeper服务==zookeeper在官方下载，需要下载带bin的压缩文件==</p><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317143325725.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317143325725.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210317143325725"></p><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317143551801.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317143551801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210317143551801"></p><blockquote><p>导入需要的依赖</p></blockquote><pre><code class="xml">        &lt;!--        zookeeper--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;            &lt;version&gt;0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;            &lt;version&gt;2.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;            &lt;version&gt;4.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;3.4.14&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!--        Bubbo--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.7.8&lt;/version&gt;        &lt;/dependency&gt;</code></pre><blockquote><p>yaml配置文件(服务提供者和服务消费者都需要添加配置)</p></blockquote><pre><code class="yaml">dubbo:  application:    name: provide-server  scan:      #提供服务的服务指定提供服务的包  服务消费者不用配置这个    base-packages: com.pl.service.impl  registry:      #注册中心 这里用的是zookeeper    address: zookeeper://127.0.0.1:2181</code></pre><blockquote><p>服务提供者</p></blockquote><pre><code class="java">@Service  //把这个类注入spring容器@DubboService  //把这个服务注册到注册中心zookeeper中供消费者调用public class MyDubboServiceImpl implements MyDubboService &#123;    @Override    public String dubboTest() &#123;        return &quot;&lt;&lt;你好啊！Dubbo！&gt;&gt;&quot;;    &#125;&#125;</code></pre><blockquote><p>服务消费者</p></blockquote><pre><code class="java">    @DubboReference //从注册中心中注入这个服务    MyDubboService myDubboService;    @Test    void contextLoads() &#123;        String s = myDubboService.dubboTest();        System.out.println(s);    &#125;</code></pre><blockquote><p>==重点！==服务消费者定义的服务必须和服务提供者的路径一致</p></blockquote><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317144326652.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317144326652.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210317144326652"></p><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317144357114.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317144357114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210317144357114"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-3-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/11/2021-3-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-Gof、Gof23"><a href="#设计模式-Gof、Gof23" class="headerlink" title="设计模式(Gof、Gof23)"></a>设计模式(Gof、Gof23)</h1><blockquote><p>创建型模式:</p></blockquote><ul><li>单例模式</li><li>工厂模式</li><li>抽象工厂模式</li><li>原型模式</li><li>建造者模式</li></ul><blockquote><p>结构型模式</p></blockquote><ul><li>适配器模式</li><li>桥接模式</li><li>装饰模式</li><li>组合模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ul><blockquote><p>行为型模式（带补充）</p></blockquote><h2 id="oop七大原则"><a href="#oop七大原则" class="headerlink" title="==oop七大原则=="></a>==oop七大原则==</h2><ul><li>开闭原则:<code>对扩展开发、对修改关闭</code></li><li>里氏替换原则:<code>继承必须确保超类所拥有的性质在子类中仍然成立</code></li><li>依赖倒置原则:<code>要面向接口编程、不用面向实现编程</code></li><li>单一职责原则:<code>控制类的粒度大小、将对象解耦、提高其内聚性</code></li><li>接口隔离原则:<code>要为各个类建立它们需要的专用接口</code></li><li>迪米特法则:<code>只与你的直接朋友交谈，不和&quot;陌生人&quot;说话</code></li><li>合成复用原则:<code>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</code></li></ul><h2 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h2><blockquote><p>作用:<strong>实现了创建者和调用者的分离</strong></p></blockquote><blockquote><p>运用的OOP七大原则:<strong>开闭原则、依赖倒置原则、迪米特法则</strong></p></blockquote><p><strong>分类</strong></p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-3-01-RabbitMQ/"/>
      <url>2021/05/11/2021-3-01-RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-MQ引言"><a href="#1-MQ引言" class="headerlink" title="1. MQ引言"></a>1. MQ引言</h2><h3 id="1-1-什么是MQ"><a href="#1-1-什么是MQ" class="headerlink" title="1.1 什么是MQ"></a>1.1 什么是MQ</h3><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093050947.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093050947.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210304093050947"></p><h3 id="1-2-MQ有哪些"><a href="#1-2-MQ有哪些" class="headerlink" title="1.2 MQ有哪些"></a>1.2 MQ有哪些</h3><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093119055.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093119055.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210304093119055"></p><h3 id="1-3-MQ的不同特点"><a href="#1-3-MQ的不同特点" class="headerlink" title="1.3 MQ的不同特点"></a>1.3 MQ的不同特点</h3><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093209610.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210304093209610.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210304093209610"></p><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2. RabbitMQ"></a>2. RabbitMQ</h2><h3 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h3><blockquote><p>基于==AMQP==协议，erlang语言开发，是部署最广泛的开源消息中间件，是最受欢迎的开源消息中间件之一。</p></blockquote><pre><code class="markdown"># AMQP 协议AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</code></pre><h2 id="Springboot整合RabbitMq"><a href="#Springboot整合RabbitMq" class="headerlink" title="Springboot整合RabbitMq"></a>Springboot整合RabbitMq</h2><p>RabbitMQ和Springboot是用一家公司的，所以它们两个的整合很方便。首先导入<code>RabbitMQ依赖</code></p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;            &lt;version&gt;2.4.3&lt;/version&gt;        &lt;/dependency&gt;</code></pre><blockquote><p>RabbitMq中声明注册交换机和声明注册消息队列可以使用Config文件来无缝完美注册！==以下以fanout模式的交换机为例子==</p></blockquote><pre><code class="java">package com.pl.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author 彭蕾 * @date 2021-03-1511:15 **/@Configurationpublic class RabbitMqConfig &#123;        //注册交换机 (fanout模式交换机，不同模式的交换机就是返回值修改为对应模式即可)FanoutExchange    @Bean    public FanoutExchange fanoutExchange()&#123;        //  &quot;fanout_order_exchange&quot; 交换机名字   true 是否次持久化  false 是否销毁        return new FanoutExchange(&quot;fanout_order_exchange&quot;,true,false);    &#125;    //注册队列    @Bean    public Queue queue1()&#123;        //  &quot;queue1&quot; 队列名字  true 是否持久化        return new Queue(&quot;queue1&quot;,true);    &#125;    @Bean    public Queue queue2()&#123;        return new Queue(&quot;queue2&quot;,true);    &#125;    @Bean    public Queue queue3()&#123;        return new Queue(&quot;queue3&quot;,true);    &#125;    //绑定交换机和队列    @Bean    public Binding bindingBuilder1()&#123;        //  bind(队列).to(交换机)        return BindingBuilder.bind(queue1()).to(fanoutExchange());    &#125;    @Bean    public Binding bindingBuilder2()&#123;        return BindingBuilder.bind(queue2()).to(fanoutExchange());    &#125;    @Bean    public Binding bindingBuilder3()&#123;        return BindingBuilder.bind(queue3()).to(fanoutExchange());    &#125;&#125;</code></pre><h3 id="一-fanout模式-生产者需要指定交换机和队列的config"><a href="#一-fanout模式-生产者需要指定交换机和队列的config" class="headerlink" title="一.fanout模式(生产者需要指定交换机和队列的config)"></a>一.fanout模式(生产者需要指定交换机和队列的config)</h3><blockquote><p>生产者</p></blockquote><pre><code class="java">/** * @author 彭蕾 * @date 2021-03-1510:42 **/@Servicepublic class RabbitMqService &#123;    @Autowired    AmqpTemplate amqpTemplate;    /**      * @Author: 彭蕾     * @Description: 创建订单     * @Param: [userId, productId, num]      * @return: void     * @Date: 2021-03-15 10:43    **/    public void makeOreder(int userId,int productId,int num)&#123;        //这里使用uuid代替消息        String uuid = UUID.randomUUID().toString();        //交换机名字        String exchang = &quot;fanout_order_exchange&quot;;        //路由key        String routerKey = &quot;&quot;;        //发送消息到交换机中        amqpTemplate.convertAndSend(exchang,routerKey,uuid);    &#125;&#125;</code></pre><blockquote><p>消费者</p></blockquote><pre><code class="java">@Component //声明该类被spring托管@RabbitListener(queues = &quot;queue1&quot;) //开启rabbitmq消费者监听 queues=&quot;&quot;监听该队列public class ConSumeService1 &#123;    @RabbitHandler //声明消息的落脚点(也就是消费者的&#39;消费处理&#39;在该注解的方法里)    public void consume(String message)&#123;        System.out.println(&quot;消费者消息接送&quot;+message);    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-03-17-SpringCloud/"/>
      <url>2021/05/11/2021-03-17-SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud?"></a>什么是SpringCloud?</h2><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317193157963.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210317193157963.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210317193157963"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-2-26-JVM/"/>
      <url>2021/05/11/2021-2-26-JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ul><li>谈谈对JVM的理解，java8虚拟机和之前的变化更新?</li><li>什么是OOM，什么是栈溢出</li><li>JVM的常用调优参数</li><li>JVM类加载器的认识</li><li>内存快照如何抓取，怎么分析Dump文件?</li></ul><ol><li><p>JVM的位置</p><p>==运行在操作系统上==</p></li><li><p>JVM的体系结构</p><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210226113636412.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210226113636412.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210226113636412"></p></li><li><p>类加载器</p></li><li><p>双亲委派机制</p></li><li><p>沙箱安全机制</p></li><li><p>Native</p></li><li><p>PC寄存器</p></li><li><p>方法区</p></li><li><p>栈</p></li><li><p>三种JVM</p></li><li><p>堆</p></li><li><p>新生区、老年区</p></li><li><p>永久区</p></li><li><p>堆内存调优</p></li><li><p>GC</p><ol><li>常用算法</li></ol></li><li><p>JMM</p></li><li><p>总结</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-2-24-JUC/"/>
      <url>2021/05/11/2021-2-24-JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><blockquote><p>什么是JUC ? ==java util concurrent== </p></blockquote><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210224091013861.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210224091013861.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210224091013861"></p><h2 id="1、线程和进程"><a href="#1、线程和进程" class="headerlink" title="1、线程和进程"></a>1、线程和进程</h2><blockquote><p>==进程: 一个程序。一个进程往往可以包含多个线程。cpu分配资源的基本单位== </p></blockquote><blockquote><p>==线程: cpu调度和分派的基本单位。== java默认2个线程main线程和GC守护线程！</p></blockquote><ul><li>并发、并行</li></ul><blockquote><p>线程有几个==状态==?</p></blockquote><pre><code class="java">public enum State &#123;                /**         * 线程新建         */        NEW,        /**         * 线程运行         */        RUNNABLE,        /**         * 线程阻塞         */        BLOCKED,        /**         * 线程等待(死死的等)         */        WAITING,        /**         * 线程超时等待         */        TIMED_WAITING,        /**         * 线程摧毁         */        TERMINATED;&#125;</code></pre><blockquote><p>wait / sleep 区别</p></blockquote><ol><li><p><strong>来自不用的类</strong></p><p>wait =&gt; Object </p><p>sleep =&gt; Thread </p></li><li><p><strong>关闭锁的释放</strong></p><p>wait会释放锁，sleep不会释放锁。</p></li><li><p><strong>使用的范围不同</strong></p><p>wait必须在同步代码块中，sleep可以在任何地方。</p></li></ol><h2 id="2、Lock锁-重点"><a href="#2、Lock锁-重点" class="headerlink" title="2、Lock锁(重点)"></a>2、Lock锁(重点)</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-2-18-SpringSecurity/"/>
      <url>2021/05/11/2021-2-18-SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity-安全框架"><a href="#SpringSecurity-安全框架" class="headerlink" title="SpringSecurity(安全框架)"></a>SpringSecurity(安全框架)</h1><p>做网站的，安全应该在什么时候考虑?</p><blockquote><p>设计之初</p></blockquote><p>shiro、Springsecurity：很像-除了类不一样，名字不一样!</p><blockquote><p>认证、授权</p></blockquote><ul><li>功能权限</li><li>访问权限</li><li>菜单权限</li><li>拦截器、过滤器、大量的原生代码冗余</li></ul><p>AOP：横切进去</p><h2 id="认证："><a href="#认证：" class="headerlink" title="认证："></a>认证：</h2><pre><code class="JAVA">//    认证    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()                .antMatchers(&quot;/&quot;).permitAll()                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);        http.formLogin();    &#125;</code></pre><h2 id="授权："><a href="#授权：" class="headerlink" title="授权："></a>授权：</h2><pre><code class="java">//    授权    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;pl&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)                .and()                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/11/2021-2-18-Shiro/"/>
      <url>2021/05/11/2021-2-18-Shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><blockquote><p>shiro主要有三大功能模块</p></blockquote><ol><li><p>Subject：主体，当前操作的对象</p></li><li><p>SecurityManager：安全管理器，管理所有的Subject，可以配合内部安全组件。</p></li><li><p>Realms：用于进行权限信息的验证，一般需要自己实现</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="2021/01/13/docker%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/13/docker%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><blockquote><p>docker启动rabbitMq</p></blockquote><pre><code class="bash">#  启动rabbitmqdocker run -d -p 5672:5672 -p 15672:15672 --name mrabbitMq rabbitmq#  进入rabbitmq内部docker exec -it 445c73c07ab6 /bin/bash#  开启rabbitmq界面rabbitmq-plugins enable rabbitmq_management</code></pre><blockquote><p>docker查看容器内网的ip地址等信息</p></blockquote><pre><code class="bash">docker inspect containerid（容器ID）</code></pre><p><img src="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210330093823150.png" class="lazyload" data-srcset="C:\Users\86156\AppData\Roaming\Typora\typora-user-images\image-20210330093823150.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210330093823150"></p><p><img src="http://imgoss.cnu.cc/2105/11/ba721b50bacb31bcaeda2edbc5354d64.jpg?width=920&height=1099&x-oss-process=style/cover280" class="lazyload" data-srcset="http://imgoss.cnu.cc/2105/11/ba721b50bacb31bcaeda2edbc5354d64.jpg?width=920&height=1099&x-oss-process=style/cover280" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Tonje Thilesen 摄影作品"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
