{"meta":{"title":"云中小屋","subtitle":"","description":"","author":"彭蕾","url":"http://pl129021.github.io","root":"/"},"pages":[{"title":"我的第一篇文章","date":"2021-05-12T01:39:00.000Z","updated":"2021-05-12T02:31:32.643Z","comments":true,"path":"index.html","permalink":"http://pl129021.github.io/index.html","excerpt":"","text":""},{"title":"CopyOnWriteArraySet源码阅读","date":"2021-05-12T02:33:00.000Z","updated":"2021-05-12T02:47:54.697Z","comments":true,"path":"CopyOnWriteArrayList源码阅读.html","permalink":"http://pl129021.github.io/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html","excerpt":"","text":"CopyOnWriteArraySet源码阅读 1Set sets = new CopyOnWriteArraySet(); // JUC包下的并发安全 CopyOnWriteArraySet 通过查看源码可知———–&gt;CopyOnWriteArraySet的底层就是new了一个==CopyOnWriteArrayList== 123456/** * 当我们实例化CopyOnWriteArraySet集合时，java底层创建的是CopyOnWriteArrayList集合 */public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();&#125; new CopyOnWriteArrayList(); 1234567891011121314151617181920/** * 当我们实例化CopyOnWriteArrayList集合时,底层调用了setArray((new Object[0]))方法 */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;/*** transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。* volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。*/private transient volatile Object[] array; add()方法 1234567891011121314151617181920212223242526272829303132333435/** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //添加元素到集合中前先加上lock锁所以==CopyOnWriteArrayList==是线程安全的 final ReentrantLock lock = this.lock; lock.lock(); //下面就执行添加元素的操作 try &#123; //获取当前数组 Object[] elements = getArray(); //获取当前数组的长度 int len = elements.length; //复制当前数组为一个长度+1的新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //把元素添加到新的数组中 newElements[len] = e; //再用新的数组替换当前的数组 就完成了添加元素的操作 setArray(newElements); return true; &#125; finally &#123; //最后释放lock锁 lock.unlock(); &#125;&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;"},{"title":"about","date":"2014-12-22T04:39:04.000Z","updated":"2021-05-12T01:58:35.190Z","comments":true,"path":"about/index.html","permalink":"http://pl129021.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2014-12-22T04:39:04.000Z","updated":"2021-05-12T01:31:40.541Z","comments":true,"path":"categories/index.html","permalink":"http://pl129021.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2014-12-22T04:39:04.000Z","updated":"2021-05-12T01:35:23.223Z","comments":true,"path":"search/index.html","permalink":"http://pl129021.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2021-05-12T01:32:32.679Z","comments":true,"path":"tags/index.html","permalink":"http://pl129021.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CopyOnWriteArraySet源码阅读","slug":"CopyOnWriteArrayList源码阅读","date":"2021-05-12T02:33:00.000Z","updated":"2021-05-12T02:47:54.697Z","comments":true,"path":"2021/05/12/CopyOnWriteArrayList源码阅读/","link":"","permalink":"http://pl129021.github.io/2021/05/12/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"CopyOnWriteArraySet源码阅读 1Set sets = new CopyOnWriteArraySet(); // JUC包下的并发安全 CopyOnWriteArraySet 通过查看源码可知———–&gt;CopyOnWriteArraySet的底层就是new了一个==CopyOnWriteArrayList== 123456/** * 当我们实例化CopyOnWriteArraySet集合时，java底层创建的是CopyOnWriteArrayList集合 */public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();&#125; new CopyOnWriteArrayList(); 1234567891011121314151617181920/** * 当我们实例化CopyOnWriteArrayList集合时,底层调用了setArray((new Object[0]))方法 */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;/*** transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。* volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。*/private transient volatile Object[] array; add()方法 1234567891011121314151617181920212223242526272829303132333435/** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //添加元素到集合中前先加上lock锁所以==CopyOnWriteArrayList==是线程安全的 final ReentrantLock lock = this.lock; lock.lock(); //下面就执行添加元素的操作 try &#123; //获取当前数组 Object[] elements = getArray(); //获取当前数组的长度 int len = elements.length; //复制当前数组为一个长度+1的新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //把元素添加到新的数组中 newElements[len] = e; //再用新的数组替换当前的数组 就完成了添加元素的操作 setArray(newElements); return true; &#125; finally &#123; //最后释放lock锁 lock.unlock(); &#125;&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://pl129021.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"CopyOnWriteArraySet","slug":"CopyOnWriteArraySet","permalink":"http://pl129021.github.io/tags/CopyOnWriteArraySet/"}]},{"title":"CopyOnWriteArraySet源码阅读","slug":"CopyOnWriteArrayList源码阅读1","date":"2021-05-12T02:33:00.000Z","updated":"2021-05-12T02:47:54.697Z","comments":true,"path":"2021/05/12/CopyOnWriteArrayList源码阅读1/","link":"","permalink":"http://pl129021.github.io/2021/05/12/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/","excerpt":"","text":"CopyOnWriteArraySet源码阅读 1Set sets = new CopyOnWriteArraySet(); // JUC包下的并发安全 CopyOnWriteArraySet 通过查看源码可知———–&gt;CopyOnWriteArraySet的底层就是new了一个==CopyOnWriteArrayList== 123456/** * 当我们实例化CopyOnWriteArraySet集合时，java底层创建的是CopyOnWriteArrayList集合 */public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();&#125; new CopyOnWriteArrayList(); 1234567891011121314151617181920/** * 当我们实例化CopyOnWriteArrayList集合时,底层调用了setArray((new Object[0]))方法 */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;/*** transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。* volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。*/private transient volatile Object[] array; add()方法 1234567891011121314151617181920212223242526272829303132333435/** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; //添加元素到集合中前先加上lock锁所以==CopyOnWriteArrayList==是线程安全的 final ReentrantLock lock = this.lock; lock.lock(); //下面就执行添加元素的操作 try &#123; //获取当前数组 Object[] elements = getArray(); //获取当前数组的长度 int len = elements.length; //复制当前数组为一个长度+1的新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //把元素添加到新的数组中 newElements[len] = e; //再用新的数组替换当前的数组 就完成了添加元素的操作 setArray(newElements); return true; &#125; finally &#123; //最后释放lock锁 lock.unlock(); &#125;&#125;/*** CopyOnWriteArrayList底层就是一个对象数组*/final void setArray(Object[] a) &#123; array = a;&#125;","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://pl129021.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"CopyOnWriteArraySet","slug":"CopyOnWriteArraySet","permalink":"http://pl129021.github.io/tags/CopyOnWriteArraySet/"}]}],"categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://pl129021.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"CopyOnWriteArraySet","slug":"CopyOnWriteArraySet","permalink":"http://pl129021.github.io/tags/CopyOnWriteArraySet/"}]}