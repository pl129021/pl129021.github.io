{"meta":{"title":"云中小屋","subtitle":"","description":"","author":"彭蕾","url":"http://pl129021.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"CopyOnWriteArrayList源码阅读","date":"2021-05-11T05:59:03.882Z","updated":"2021-02-25T01:48:22.172Z","comments":true,"path":"2021/05/11/CopyOnWriteArrayList源码阅读/","link":"","permalink":"http://pl129021.github.io/2021/05/11/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"","text":"CopyOnWriteArraySet源码阅读 Set sets = new CopyOnWriteArraySet(); // JUC包下的并发安全 CopyOnWriteArraySet 通过查看源码可知———–&gt;CopyOnWriteArraySet的底层就是new了一个==CopyOnWriteArrayList== /** * 当我们实例化CopyOnWriteArraySet集合时，java底层创建的是CopyOnWriteArrayList集合 */ public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); &#125; new CopyOnWriteArrayList(); /** * 当我们实例化CopyOnWriteArrayList集合时,底层调用了setArray((new Object[0]))方法 */ public CopyOnWriteArrayList() &#123; setArray(new Object[0]); &#125; /** * CopyOnWriteArrayList底层就是一个对象数组 */ final void setArray(Object[] a) &#123; array = a; &#125; /** * transient是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为transient的变量不会被序列化。 * volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 */ private transient volatile Object[] array; add()方法 /** * 将指定的元素追加到此列表的末尾。 * * @param e 要添加到此列表的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; //添加元素到集合中前先加上lock锁所以==CopyOnWriteArrayList==是线程安全的 final ReentrantLock lock = this.lock; lock.lock(); //下面就执行添加元素的操作 try &#123; //获取当前数组 Object[] elements = getArray(); //获取当前数组的长度 int len = elements.length; //复制当前数组为一个长度+1的新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //把元素添加到新的数组中 newElements[len] = e; //再用新的数组替换当前的数组 就完成了添加元素的操作 setArray(newElements); return true; &#125; finally &#123; //最后释放lock锁 lock.unlock(); &#125; &#125; /** * CopyOnWriteArrayList底层就是一个对象数组 */ final void setArray(Object[] a) &#123; array = a; &#125;","categories":[],"tags":[]},{"title":"","slug":"2021-3-16-分布式-dubbo-zookeeper","date":"2021-05-11T05:59:03.879Z","updated":"2021-03-17T06:49:30.581Z","comments":true,"path":"2021/05/11/2021-3-16-分布式-dubbo-zookeeper/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-3-16-%E5%88%86%E5%B8%83%E5%BC%8F-dubbo-zookeeper/","excerpt":"","text":"分布式/Dubbo/Zookeeper 什么是分布式系统? ==分布式系统是若干独立计算机的集合，这计算机对用户来说就像单个相关系统。== 什么是Dubbo? 一个远程调用服务的分布式框架，可以实现远程通讯、动态配置、地址路由。Dubbo实现服务调用是通过RPC的方式 什么是Zookeeper? ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，类似一个服务注册中心。 Springboot实现简单分布式demo 首先需要安装zookeeper并且启动zookeeper服务==zookeeper在官方下载，需要下载带bin的压缩文件== 导入需要的依赖 &lt;!-- zookeeper--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- Bubbo--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt; yaml配置文件(服务提供者和服务消费者都需要添加配置) dubbo: application: name: provide-server scan: #提供服务的服务指定提供服务的包 服务消费者不用配置这个 base-packages: com.pl.service.impl registry: #注册中心 这里用的是zookeeper address: zookeeper://127.0.0.1:2181 服务提供者 @Service //把这个类注入spring容器 @DubboService //把这个服务注册到注册中心zookeeper中供消费者调用 public class MyDubboServiceImpl implements MyDubboService &#123; @Override public String dubboTest() &#123; return &quot;&lt;&lt;你好啊！Dubbo！&gt;&gt;&quot;; &#125; &#125; 服务消费者 @DubboReference //从注册中心中注入这个服务 MyDubboService myDubboService; @Test void contextLoads() &#123; String s = myDubboService.dubboTest(); System.out.println(s); &#125; ==重点！==服务消费者定义的服务必须和服务提供者的路径一致","categories":[],"tags":[]},{"title":"","slug":"2021-3-01-设计模式","date":"2021-05-11T05:59:03.876Z","updated":"2021-03-01T07:20:34.576Z","comments":true,"path":"2021/05/11/2021-3-01-设计模式/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-3-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式(Gof、Gof23) 创建型模式: 单例模式 工厂模式 抽象工厂模式 原型模式 建造者模式 结构型模式 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式 行为型模式（带补充） ==oop七大原则== 开闭原则:对扩展开发、对修改关闭 里氏替换原则:继承必须确保超类所拥有的性质在子类中仍然成立 依赖倒置原则:要面向接口编程、不用面向实现编程 单一职责原则:控制类的粒度大小、将对象解耦、提高其内聚性 接口隔离原则:要为各个类建立它们需要的专用接口 迪米特法则:只与你的直接朋友交谈，不和&quot;陌生人&quot;说话 合成复用原则:尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 1、工厂模式 作用:实现了创建者和调用者的分离 运用的OOP七大原则:开闭原则、依赖倒置原则、迪米特法则 分类 简单工厂模式工厂方法模式抽象工厂模式","categories":[],"tags":[]},{"title":"","slug":"2021-3-01-RabbitMQ","date":"2021-05-11T05:59:03.873Z","updated":"2021-03-17T06:50:11.076Z","comments":true,"path":"2021/05/11/2021-3-01-RabbitMQ/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-3-01-RabbitMQ/","excerpt":"","text":"RabbitMQ1. MQ引言1.1 什么是MQ 1.2 MQ有哪些 1.3 MQ的不同特点 2. RabbitMQ2.1 RabbitMQ 基于==AMQP==协议，erlang语言开发，是部署最广泛的开源消息中间件，是最受欢迎的开源消息中间件之一。 # AMQP 协议 AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。 Springboot整合RabbitMqRabbitMQ和Springboot是用一家公司的，所以它们两个的整合很方便。首先导入RabbitMQ依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; RabbitMq中声明注册交换机和声明注册消息队列可以使用Config文件来无缝完美注册！==以下以fanout模式的交换机为例子== package com.pl.config; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @author 彭蕾 * @date 2021-03-1511:15 **/ @Configuration public class RabbitMqConfig &#123; //注册交换机 (fanout模式交换机，不同模式的交换机就是返回值修改为对应模式即可)FanoutExchange @Bean public FanoutExchange fanoutExchange()&#123; // &quot;fanout_order_exchange&quot; 交换机名字 true 是否次持久化 false 是否销毁 return new FanoutExchange(&quot;fanout_order_exchange&quot;,true,false); &#125; //注册队列 @Bean public Queue queue1()&#123; // &quot;queue1&quot; 队列名字 true 是否持久化 return new Queue(&quot;queue1&quot;,true); &#125; @Bean public Queue queue2()&#123; return new Queue(&quot;queue2&quot;,true); &#125; @Bean public Queue queue3()&#123; return new Queue(&quot;queue3&quot;,true); &#125; //绑定交换机和队列 @Bean public Binding bindingBuilder1()&#123; // bind(队列).to(交换机) return BindingBuilder.bind(queue1()).to(fanoutExchange()); &#125; @Bean public Binding bindingBuilder2()&#123; return BindingBuilder.bind(queue2()).to(fanoutExchange()); &#125; @Bean public Binding bindingBuilder3()&#123; return BindingBuilder.bind(queue3()).to(fanoutExchange()); &#125; &#125; 一.fanout模式(生产者需要指定交换机和队列的config) 生产者 /** * @author 彭蕾 * @date 2021-03-1510:42 **/ @Service public class RabbitMqService &#123; @Autowired AmqpTemplate amqpTemplate; /** * @Author: 彭蕾 * @Description: 创建订单 * @Param: [userId, productId, num] * @return: void * @Date: 2021-03-15 10:43 **/ public void makeOreder(int userId,int productId,int num)&#123; //这里使用uuid代替消息 String uuid = UUID.randomUUID().toString(); //交换机名字 String exchang = &quot;fanout_order_exchange&quot;; //路由key String routerKey = &quot;&quot;; //发送消息到交换机中 amqpTemplate.convertAndSend(exchang,routerKey,uuid); &#125; &#125; 消费者 @Component //声明该类被spring托管 @RabbitListener(queues = &quot;queue1&quot;) //开启rabbitmq消费者监听 queues=&quot;&quot;监听该队列 public class ConSumeService1 &#123; @RabbitHandler //声明消息的落脚点(也就是消费者的&#39;消费处理&#39;在该注解的方法里) public void consume(String message)&#123; System.out.println(&quot;消费者消息接送&quot;+message); &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"2021-03-17-SpringCloud","date":"2021-05-11T05:59:03.871Z","updated":"2021-03-17T12:04:04.919Z","comments":true,"path":"2021/05/11/2021-03-17-SpringCloud/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-03-17-SpringCloud/","excerpt":"","text":"SpringCloud什么是SpringCloud?","categories":[],"tags":[]},{"title":"","slug":"2021-2-26-JVM","date":"2021-05-11T05:59:03.868Z","updated":"2021-02-26T03:36:37.917Z","comments":true,"path":"2021/05/11/2021-2-26-JVM/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-2-26-JVM/","excerpt":"","text":"JVM 谈谈对JVM的理解，java8虚拟机和之前的变化更新? 什么是OOM，什么是栈溢出 JVM的常用调优参数 JVM类加载器的认识 内存快照如何抓取，怎么分析Dump文件? JVM的位置 ==运行在操作系统上== JVM的体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 栈 三种JVM 堆 新生区、老年区 永久区 堆内存调优 GC 常用算法 JMM 总结","categories":[],"tags":[]},{"title":"","slug":"2021-2-24-JUC","date":"2021-05-11T05:59:03.865Z","updated":"2021-03-17T06:49:50.422Z","comments":true,"path":"2021/05/11/2021-2-24-JUC/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-2-24-JUC/","excerpt":"","text":"JUC 什么是JUC ? ==java util concurrent== 1、线程和进程 ==进程: 一个程序。一个进程往往可以包含多个线程。cpu分配资源的基本单位== ==线程: cpu调度和分派的基本单位。== java默认2个线程main线程和GC守护线程！ 并发、并行 线程有几个==状态==? public enum State &#123; /** * 线程新建 */ NEW, /** * 线程运行 */ RUNNABLE, /** * 线程阻塞 */ BLOCKED, /** * 线程等待(死死的等) */ WAITING, /** * 线程超时等待 */ TIMED_WAITING, /** * 线程摧毁 */ TERMINATED; &#125; wait / sleep 区别 来自不用的类 wait =&gt; Object sleep =&gt; Thread 关闭锁的释放 wait会释放锁，sleep不会释放锁。 使用的范围不同 wait必须在同步代码块中，sleep可以在任何地方。 2、Lock锁(重点)","categories":[],"tags":[]},{"title":"","slug":"2021-2-18-SpringSecurity","date":"2021-05-11T05:59:03.854Z","updated":"2021-02-18T06:49:25.064Z","comments":true,"path":"2021/05/11/2021-2-18-SpringSecurity/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-2-18-SpringSecurity/","excerpt":"","text":"SpringSecurity(安全框架)做网站的，安全应该在什么时候考虑? 设计之初 shiro、Springsecurity：很像-除了类不一样，名字不一样! 认证、授权 功能权限 访问权限 菜单权限 拦截器、过滤器、大量的原生代码冗余 AOP：横切进去 认证：// 认证 @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); http.formLogin(); &#125; 授权：// 授权 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;) .and() .withUser(&quot;pl&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;); &#125;","categories":[],"tags":[]},{"title":"","slug":"2021-2-18-Shiro","date":"2021-05-11T05:59:03.851Z","updated":"2021-02-18T07:07:19.763Z","comments":true,"path":"2021/05/11/2021-2-18-Shiro/","link":"","permalink":"http://pl129021.github.io/2021/05/11/2021-2-18-Shiro/","excerpt":"","text":"Shiro shiro主要有三大功能模块 Subject：主体，当前操作的对象 SecurityManager：安全管理器，管理所有的Subject，可以配合内部安全组件。 Realms：用于进行权限信息的验证，一般需要自己实现","categories":[],"tags":[]},{"title":"docker","slug":"docker笔记","date":"2021-01-13T12:46:25.000Z","updated":"2021-05-11T06:24:06.837Z","comments":true,"path":"2021/01/13/docker笔记/","link":"","permalink":"http://pl129021.github.io/2021/01/13/docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"docker docker启动rabbitMq # 启动rabbitmq docker run -d -p 5672:5672 -p 15672:15672 --name mrabbitMq rabbitmq # 进入rabbitmq内部 docker exec -it 445c73c07ab6 /bin/bash # 开启rabbitmq界面 rabbitmq-plugins enable rabbitmq_management docker查看容器内网的ip地址等信息 docker inspect containerid（容器ID）","categories":[],"tags":[]}],"categories":[],"tags":[]}